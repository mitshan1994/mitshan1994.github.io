---
layout: post
title:  "Notes on Large Scale CPP"
categories: cpp
---

This is basically reading notes on *Large-Scale C++ Software Design*, by John Lakos.

### Physical Design Rules

* (Major) Logical entities declared within a component should not be defined outside that component.
* (Major) The .c file of every component should include its own .h file as the first substantive line of code.
* (Guideline) Clients should include header files providing required type definitions directly; Except for non-private inheritance, avoid relying on one header file to include another.
* (Major) Avoid definitions with external linkage in the .c file of a component that are not declared explicitly in the corresponding .h file.

### Principles
The DependOn relation for component is transitive.

A component defining a function will usually have a physical dependency on any component defining a type used by that function.

A component defining a class that IsA or HasA user-defined type always has a compile-time dependency on the component defining that type.

The include graph generated by C++ preprocessor *#include* directives should alone be sufficient to infer all physical dependencies within a system provided the system compiles.

Friendship within a component is an implementation detail of that component.

Granting (local) friendship to classes defined within the same component does not violate encapsulation.

Defining an iterator class along with a container class *in the same component* enables user extensibility, improves maintainability, and enhances reusability while preserving encapsulation.

Granting (long-distance) friendship to a logical entity defined in a seperate physical part of the system violates the encapsulation of the class granting that friendship.

Every directed acyclic graph can be assgined unique level numbers; a graph with cycles cannot.

In most real-world situations, large designs must be levelizable if they are to be tested effectively.

Hierarchical testing requires a seperate test driver for every component.

Testing only the functionality *directly implemented* within a component enables the complexity of the test to be proportional to the complexity of the component.

Cyclic physical dependencies among components inhibit understanding, testing, and reuse.

Acyclic physical dependencies can dramatically reduce link-time costs associated with developing, maintaining, and testing large systems.

Minimizing CCD for *a given set of components* is a design goal.

Allowing two components to "know" about each other via `#include` directives implies cyclic physical dependency.

If peer components are cyclicly dependent, it may be possible to **escalate** the interdependent functionality from each of these components to static members in a potentially new higher-level component that depends on each of the original component.

Cyclic physical dependencies is large, low-level subsystems have the greatest capacity to increase the overall cost of maintaining a system.

If peer components are cyclicly dependent, it may be possible to **demote** the interdependent functionality from each of the components to a potentially new lower-level (shared) component upon which each of the original components depends.

Demoting common code enables independent reuse.

Escalating policy and demoting the infrastructure can be combined to enhance independent use.

Factoring a concrete class into two classes containing higher and lower levels of functionality can facilitate levelization.

Factoring an abstract base class into two classes - one defining a pure interface, the other defining its partial implementation - can facilitate levelization.

Factoring a system into smaller components makes it both more flexible and also more complex, since there are now more physical pieces to work with.

Components that use objects in name only can be thoroughly tested independently of the named object.

If a contained object holds a pointer to its container and implements functionality that depends substantively on that container, then we can eliminate mutual dependency by (1) making the pointer in the contained class opaque, (2) providing access to the container pointer in the public interface of the contained class, and (3) escalating the affected methods of the contained class to static member of the container class.



### Guidelines
A component x should include y.h only if x makes direct substantive use of a class or free operator function defined in y.

Avoid granting (long-distance) friendship to a logical entity defined in another component.



### Some Definitions
We can define **implementation dependency** for functions loosely by saying that a function depends on a component if that component is needed in order to compile and link the body of that function.

So we have the definition: **A component y *DependsOn* a component x if x is needed in order to compile or link y.**

**A component y exhibits a *compile-time* dependency on component x if x.h is need in order to compile y.c.**

**A component y exhibits a *link-time* dependency on component x if the object y.o contains undefined symbols for which x.o may be called upon either directly or indirectly to help resolve at link time.**

Level number definition:
* **Level 0**: A component that is external to our package.
* **Level 1**: A component that has no local physical dependencies.
* **Level N**: A component that depends physically on a component at level N-1, but not higher.

A level-1 component that depends only on compiler-supplied libraries is called a *leaf* component. Leaf components are always testable in isolation.

**Hierarchical testing** refers to the practice of testing individual components at each level of the physical hierarchy.

**Incremental testing** refers to the practice of deliberately testing only the functionality actually implemented within the component under test.

**White-box testing** refers to the practice of verifying the expected behaviour of a component by exploiting knowledge of its underlying implementation.

**Black-box testing** refers to the practice of verifying the expected behaviour of a component based solely on its specification.

**Cumulative component dependency(CCD)** is the sum over all components C(i) in a subsystem of the number of components needed in order to test each C(i) incrementally.

**Average component dependency(ACD)** is defined as the ratio of the CCD of a subsystem to the number of components N in the subsystem:
```
ACD(subsystem) = CCD(subsystem) / N
```

**Normalized cumulative component dependency(NCCD)** is defined as the ratio of the CCD of a subsystem containing N components to the CCD of a tree-like system of the same size:
```
NCCD(subsystem) = CCD(subsystem) / CCD_balanced_binary(N_subsystem)
```

A subsystem is **levelizable** if it compiles and the graph implied by the include directives of the individual components (including the .c files) is acyclic.

A component y **dominates** a component x if y is at a higher level than x and y depends on x physically.

A function f uses a type T **in size** if compiling the body of f requires having first seen the definition of T.

A function f uses a type T **in name** only if compiling f and any of the components on which f may depend does not require having first seen the definition of T.

A pointer is said to be **opaque** if the definition of the type to which it points to is not included in the current translation unit.

**Dumb data** is any kind of information that an object holds but does not know how to interpret. (Like opaque pointer)


### Random Notes
The low-level component test should be updated to expose the errant behaviour before the defect is repaired. (It definitely facilitates the repair)

NCCD is *not* a measure of the relative quality of a system. NCCD is simply a tool for characterizing the degree of coupling within a subsystem.

The precise numerical value of the CCD (or the NCCD) for a given system is not important. What is important is actively designing systems to keep the CCD for each subsystem from becoming larger than necessary.

